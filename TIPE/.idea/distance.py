import matplotlib.pyplot as pltimport numpy as npfrom PyQt5.QtCore import *from PyQt5.QtGui import *from PyQt5.QtWidgets import *import sysimport random as rdfrom ui_fenetre import Ui_MainWindowclass fenetreLignes(QMainWindow,Ui_MainWindow):    def __init__(self,parent=None):        super().__init__(parent)        self.setupUi(self)        self.setGeometry(600,100,1900,1000)        self.canvas=ZoneG(self)        self.canvas.setGeometry(450,100,853,567)class ZoneG(QWidget):    def __init__(self,parent=None):        super().__init__(parent)        self.qp=QPixmap(1000,1000)        self.qp.fill(Qt.white)        self.liste_abcisse = []        self.liste_ordonnee = []        p = QPainter(self.qp)        p.setBrush(Qt.black)        image = QImage()        image.load("../terrain.jpg")        p.drawImage(QRect(0, 0, 853, 567),image)        p.drawEllipse(0, 0, 10, 10)        p.drawEllipse(0, 554, 10, 10)        p.drawEllipse(840, 0, 10, 10)        self.joueur(p)    def paintEvent(self, QPaintEvent):        p=QPainter(self)        p.drawPixmap(0,0,self.qp)    def mousePressEvent(self, QMouseEvent):        xpos=QMouseEvent.x()        ypos=QMouseEvent.y()        print(xpos, ypos)        p=QPainter(self.qp)        p.setPen(Qt.red)        p.setBrush(Qt.blue)        p.drawEllipse(xpos-10,ypos-10,10,10)        self.update()    def joueur(self, p):        pen = QPen(Qt.black)        p.setBrush(Qt.red)        pen.setWidth(2)        p.setPen(pen)        x0, y0 = 500, 250        x1, y1 = rd.randint(x0-100, x0+100), rd.randint(y0-100, y0+100)        self.liste_abcisse.append(x0)        self.liste_ordonnee.append(y0)        self.liste_abcisse.append(x1)        self.liste_ordonnee.append(y1)        p.drawEllipse(x0, y0, 10, 10)        p.drawEllipse(x1, y1, 10, 10)        p.drawLine(x0, y0, x1, y1)        i = 0        #for _ in range(100):        while i <= 50:            x0, y0 = x1, y1            x1, y1 = rd.randint(x0-100, x0+100), rd.randint(y0-100, y0+100)            if 50 <= x1 <= 820 and 15 <= y1 <= 550:                self.liste_abcisse.append(x1)                self.liste_ordonnee.append(y1)            #x1, y1 = rd.randint(0, 1000), rd.randint(0,500)                p.drawEllipse(x1, y1, 10, 10)                p.drawLine(x0, y0, x1, y1)                i += 1            else:                x1, y1 = rd.randint(x0 - 100, x0 + 100), rd.randint(y0 - 100, y0 + 100)        self.update()        nombre_points = 54        nombre_simulations = 1000000        liste_abcisse, liste_ordonnee = self.liste_abcisse, self.liste_ordonnee        plt.plot(liste_abcisse, liste_ordonnee, 'bo')        plt.plot(liste_abcisse, liste_ordonnee, 'r-')        plt.xlim(0, 100)        plt.ylim(0, 50)        plt.show()        def distance_euclidienne(liste_abcisses, liste_ordonnees):            n = len(liste_abcisses)            distance = 0            for i in range(n - 1):                x1 = liste_abcisses[i]                x2 = liste_abcisses[i + 1]                y1 = liste_ordonnees[i]                y2 = liste_ordonnees[i + 1]                distance += np.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)            return distance        distance = distance_euclidienne(liste_abcisse, liste_ordonnee)        print("Distance parcourue: ", distance)        def generateur_coordonnees_modele_1(liste_abcisses, liste_ordonnees, nombre_points, nombre_simulations):            matrice_abcisses = []  # initialisation de l'ensemble des listes des abcisses            matrice_ordonnees = []  # initialisation de l'ensemble des listes des ordonnees            for _ in range(nombre_simulations):                matrice_abcisses.append([])                matrice_ordonnees.append([])            for i in range(nombre_points):  # iteration pour chaque coordonnees                x0 = liste_abcisses[i]  # recuperation de la ieme abcisse                y0 = liste_ordonnees[i]  # recuperation de la ieme ordonnees                for j in range(nombre_simulations):  # On releve n point coordonnees au tour de chaque point                    x1 = rd.uniform(x0 - 1, x0 + 1)  # aleatoirement                    y1 = rd.uniform(y0 - 1, y0 + 1)                    matrice_abcisses[j].append(x1)  # ajout a la jeme liste des abcisses                    matrice_ordonnees[j].append(y1)  # ajout a la jeme liste des ordonnees            return matrice_abcisses, matrice_ordonnees        matrice_abcisses, matrice_ordonnees = generateur_coordonnees_modele_1(liste_abcisse, liste_ordonnee, nombre_points, nombre_simulations)        dist = []        for i in range(nombre_simulations):            dist.append(distance_euclidienne(matrice_abcisses[i], matrice_ordonnees[i]))        plt.hist(dist, 'auto', alpha=0.4, edgecolor='blue')        plt.show()        print('distance moyenne :', np.mean(dist))app = QApplication(sys.argv)essai = fenetreLignes()essai.show()app.exec()